# Завдання  1.3. КР2 Продемонструйте операції обходу дерева  (на основы Завдання 1.2 )
# у порядку Inorder (симетричний) та Postorder (зворотний). 

#Inorder(Симетричний) обхід: лівий->корінь->правий.Результат.  Елементи виводить у відсортованому порядку.
#Postorder(Зворотний) обхід: лівий->правий->корінь. Для видалення дерева.

#клас вузла дерева
class Node:
    def __init__(self, data):
        self.data = data # дані, які зберігає вузол (ключ BST)
        self.left = None  # посилання на менші значення (лівий нащадок)
        self.right = None # посилання на більші значення (правий нащадок)
        
# клас бінарного дерева пошуку (BST)
class BST:
    def __init__(self):
        self.root = None #вказує на кореневий вузол (початок структури)
    
    #функція для вставки елемента (використовуємо дл для побудови дерева)
    def insert(self, data):
        new_node = Node(data)
        
        #якщо дерево порожнє
        if self.root is None:
            self.root = new_node
            return
        #якщо пошук місця для вставки (ітеративно)
        current = self.root #починаємо з кореня
        while True:
            #рух вліво (якщо нове значення data менше за поточний вузол current.data)
            if data < current.data: 
                if current.left is None:
                    current.left = new_node #вставка тут - новий вузол new_node стає нащадком  
                    return
                current = current.left #пересуваємося вліво
            #рух вправо (якщо нове значення data > значення поточного вузла current.data)
            elif data > current.data:
                if current.right is None: #знайшли місце вставки
                    current.right = new_node 
                    return
                current = current.right #пересуваємося вправо
            else:               
                return  #елемент вже існує (дублікати ігноруються)
#------------------------------------------------------------------------------
    #Inorder(Симетричний) обхід (лівий->корінь->правий)
    def inorder_walk(self, node): #передаємо поточний вузол (посилання на Node)
        #якщо node не не існує, тобто ще не дійшли до кінця гілки
        if node is not None:
            #обхід правого піддерева (рекурсивний виклик з передачаю лівого нащадка)
            #максимально вліво до найменшого невідвіданого елемента
            self.inorder_walk(node.left)
            
            print(node.data, end=" ") #відвідування кореня (вивід даних поточного вузла)
            
            #обхід правого піддерева (рекурсивний виклик з передачаю правого нащадка)
            #відвідаємо всі елементи більші за поточний вузол ( але менші за його батька,якщо б такий був)
            self.inorder_walk(node.right) 


    #Postorder(Зворотний) обхід (лівий->правий->корінь)
    def postorder_walk(self, node):
        if node is not None:
            #обхід правого піддерева (рекурсивний виклик з передачаю лівого нащадка)
            self.postorder_walk(node.left)
            #обхід правого піддерева (рекурсивний виклик з передачаю правого нащадка) 
            self.postorder_walk(node.right) 
            print(node.data, end=" ") #відвідування кореня (вивід даних поточного вузла)
#------------------------------------------------------------------------------
bst = BST()
elements = [60, 40, 80, 20, 50, 70, 90, 10]
print(f"Вставка заданих елементів BST: {elements}")

for elem in elements:
    bst.insert(elem)
    
#Inorder 
print("\nInorder обхід (симетричний)")
print("Результат (елементи виводить у відсортованому порядку):", end=" ")
bst.inorder_walk(bst.root)
print()

#Postorder
print("\nPostorder обхід (зворотний)")
print("Результат (не відсортовано, оскільки корінь обробляється після обох своїх піддерев):", end=" ")
bst.postorder_walk(bst.root)
print()    
    
