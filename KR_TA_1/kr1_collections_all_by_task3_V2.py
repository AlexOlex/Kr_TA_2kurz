#Завдання по варіантам (варіант 2)  до пункту 3 КР

# Завдання 3.2.2.1 на одновимірний список
# Дано список слів. Знайти та вивести найдовше слово та кількість 
# його входжень у список. 

def find_longest_word(word_list: list) -> tuple:
    if not word_list:
        return "Список порожній", 0
    
    # ініціалізація змінних
    longest_word = ""
    max_length = 0
    
    # пошук найдовшого слова
    for word in word_list:
        if len(word) > max_length:
            max_length = len(word)
            longest_word = word
            
    # обчислення кількості входжень
    count = word_list.count(longest_word)
    
    return longest_word, count

# Завдання 3.2.2.2 на вкладений список 
# Дано квадратну матрицю N×N. Поміняти місцями k-й рядок
# з m-м рядком (де k та m — задані індекси). 
def swap_rows_of_matrix(matrix: list, k: int, m: int) -> list:
    N = len(matrix)
    
    # перевірка на коректність індексів
    if not (0 <= k < N and 0 <= m < N):
        return "Некоректні індекси рядків (k, m)"
    
    # обмін рядків за допомогою множинного присвоєння 
    matrix[k], matrix[m] = matrix[m], matrix[k]
    
    return matrix

# Завдання 3.2.2.3 на список та кортеж 
# Приклад для пояснення чому кортежі використовуються для повернення 
# кількох значень із функції. 

def explain_tuple_return(R: float):
    area = 3.14 * R**2
    circumf = 2 * 3.14 * R
    
    # неявне повернення кортежу (area, circumf)
    # читабельно і гарантує незмінність повернутих значень
    return area, circumf
    
# Завдання 3.3.3. на множини
# Дано дві множини C та D. Знайдіть їхнє об'єднання та симетричну різницю (C⊕D). 
def sets_union_and_diff(C: set, D: set) -> tuple:

    # об'єднання - елементи належать C АБО D
    union_set = C | D
    
    # симетрична різниця (C⊕D) - елементи, що належать C АБО D,
    # але не обом (унікальні для кожної множини)
    symm_diff_set = C ^ D
    
    return union_set, symm_diff_set

# Завдання 3.4.2. на словники
# Напишіть функцію, яка інвертує словник (значення стають ключами, ключі – 
# значеннями). Як ви вирішите проблему, якщо вихідні значення не є унікальними?
# ключами є слова з тексту, а значеннями – їхня частота появи. 

# функція інвертує словник (значення стають ключами, ключі – 
# значеннями). Як ви вирішити проблему, якщо вихідні значення не є унікальними
def invert_dictionary(input_dict: dict) -> dict:
    inverted_dict = {}
    
    # ітерація по парах ключ-значення
    for key, value in input_dict.items():
        # ключ (старе значення) повинен бути хешованим (незмінюваним)
        # перевіряємо чи нове значення (старий ключ) вже існує
        if value in inverted_dict:
            # якщо існує, додаємо старий ключ до списку
            inverted_dict[value].append(key)
        else:
            # якщо не існує, створюємо новий запис зі списком для зберігання ключів
            inverted_dict[value] = [key]
            
    return inverted_dict


if __name__ == '__main__':
    print()
    print("***** ТЕСТУВАННЯ ЗАВДАНЬ ПУНКТУ 3 КР1 ВАРІАНТ 2 ******")
    
    # Тест 3.2.2.1
    print("\n* Завдання 3.2.2.1 на одновимірний список *")
    print("* Дано список слів. Знайти та вивести найдовше слово та кількість його входжень у список *")
    words_1 = ["стул", "диван", "полиця", "полиця", "полиця"]
    longest_1, count_1 = find_longest_word(words_1)
    
    words_2 = ["сонце", "місяць", "земля"] # Перевірка, коли всі слова унікальні
    longest_2, count_2 = find_longest_word(words_2)
    
    words_3 = ["кіт", "пес", "лев"] # Перевірка, коли найдовших декілька
    longest_3, count_3 = find_longest_word(words_3)
    
    words_4 = [] # Крайовий випадок (порожній список)
    longest_4, count_4 = find_longest_word(words_4)
    
    print(f"\nТест 1: список: {words_1}")
    print(f"результат: '{longest_1}', кількість: {count_1}")
    print(f"\nТест 2: список: {words_2}")
    print(f"результат: '{longest_2}', кількість: {count_2}")
    print(f"\nТест 3 (найдовших декілька): список: {words_3}")
    print(f"результат: '{longest_3}', кількість: {count_3}")
    print(f"\nТест 4 (порожній): список: {words_4}")
    print(f"результат: '{longest_4}', кількість: {count_4}")
    
    # Тест 3.2.2.2
    print("\n* Завдання 3.2.2.2 на вкладений список *")
    print("* Дано квадратну матрицю N×N. Поміняти місцями k-й рядок з m-м рядком (де k та m — задані індекси *)") 
    M_initial = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    M_copy_1 = [row[:] for row in M_initial] # Копія для тесту 1
    M_copy_2 = [row[:] for row in M_initial] # Копія для тесту 2
    
    k1, m1 = 0, 2 # Обмін 0-го та 2-го рядків
    k2, m2 = 1, 1 # Обмін рядка сам на себе
    k3, m3 = 0, 5 # Некоректний індекс

    M_swap_1 = swap_rows_of_matrix(M_copy_1, k1, m1)
    M_swap_2 = swap_rows_of_matrix(M_copy_2, k2, m2)
    M_swap_3 = swap_rows_of_matrix(M_initial, k3, m3)

    print("\nТест 1 (0 <-> 2):")
    print(f"Матриця після: {M_swap_1}")
    print("\nТест 2 (1 <-> 1, без змін):")
    print(f"Матриця після: {M_swap_2}")
    print("\nТест 3 (Некоректний індекс 5):")
    print(f"результат: {M_swap_3}")
    
    # Тест 3.2.2.3
    print("\n* Завдання 3.2.2.3 на список та кортеж *")
    print("* Приклад для пояснення чому кортежі використовуються для повернення кількох значень із функції * ")
    res_tuple = explain_tuple_return(R=5)
    print(f"\nПриклад: Функція повертає: {res_tuple}")
    print(f"Тип поверненого об'єкта: {type(res_tuple)}")
    
    # Тест 3.3.3.
    print("\n* Завдання 3.3.3. на множини *")
    print("* Дано дві множини C та D. Знайдіть їхнє об'єднання та симетричну різницю (C⊕D) *")
    C1 = {1, 2, 3, 4}
    D1 = {3, 4, 5, 6}
    union_1, diff_1 = sets_union_and_diff(C1, D1)
    
    C2 = {1, 2}
    D2 = {5, 6} # Диск'юнктні (не перетинаються)
    union_2, diff_2 = sets_union_and_diff(C2, D2)
    
    print(f"\nТест 1: C: {C1}, D: {D1}")
    print(f"об'єднання (C ∪ D): {union_1}")
    print(f"симетрична різниця (C ⊕ D): {diff_1}")
    
    print(f"\nТест 2 (диск'юнктні): C: {C2}, D: {D2}")
    print(f"об'єднання (C ∪ D): {union_2}")
    print(f"симетрична різниця (C ⊕ D): {diff_2}")
    
    # Тест 3.4.2.
    print("\n* Завдання 3.4.2. на словники *")
    print("* Напишіть функцію, яка інвертує словник *")
    test_dict_1 = {'a': 11, 'b': 17, 'c': 11, 'd': 13} # Значення '11' є неунікальним
    inverted_1 = invert_dictionary(test_dict_1)
    
    test_dict_2 = {1: 'x', 2: 'y', 3: 'z'} # Усі значення унікальні
    inverted_2 = invert_dictionary(test_dict_2)
    
    print("\nТест 1 (з неунікальними значеннями):")
    print(f"був словник: {test_dict_1}")
    print(f"інвертований словник: {inverted_1}")
    print("Рішення: неунікальне значення '11' пов'язане зі списком ['a', 'c'].")

    print("\nТест 2 (з унікальними значеннями):")
    print(f"був словник: {test_dict_2}")
    print(f"інвертований словник: {inverted_2}")