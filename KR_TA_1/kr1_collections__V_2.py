#Завдання по варіантам (варіант 2)  до пункту 3 КР

# Завдання 3.2.2.1 на одновимірний список
# Дано список слів. Знайти та вивести найдовше слово та кількість 
# його входжень у список. 

def find_longest_word(word_list: list) -> tuple:
    if not word_list:
        return "Список порожній", 0
    
    # ініціалізація змінних
    longest_word = ""
    max_length = 0
    
    # пошук найдовшого слова
    for word in word_list:
        if len(word) > max_length:
            max_length = len(word)
            longest_word = word
            
    # обчислення кількості входжень
    count = word_list.count(longest_word)
    
    return longest_word, count

# Завдання 3.2.2.2 на вкладений список 
# Дано квадратну матрицю N×N. Поміняти місцями k-й рядок
# з m-м рядком (де k та m — задані індекси). 
def swap_rows_of_matrix(matrix: list, k: int, m: int) -> list:
    N = len(matrix)
    
    # перевірка на коректність індексів
    if not (0 <= k < N and 0 <= m < N):
        return "Некоректні індекси рядків (k, m)"
    
    # обмін рядків за допомогою множинного присвоєння 
    matrix[k], matrix[m] = matrix[m], matrix[k]
    
    return matrix

# Завдання 3.2.2.3 на список та кортеж 
# Приклад для пояснення чому кортежі використовуються для повернення 
# кількох значень із функції. 

def explain_tuple_return(R: float):
    area = 3.14 * R**2
    circumf = 2 * 3.14 * R
    
    # неявне повернення кортежу (area, circumf)
    # читабельно і гарантує незмінність повернутих значень
    return area, circumf
    
# Завдання 3.3.3. на множини
# Дано дві множини C та D. Знайдіть їхнє об'єднання та симетричну різницю (C⊕D). 
def sets_union_and_diff(C: set, D: set) -> tuple:

    # об'єднання - елементи належать C АБО D
    union_set = C | D
    
    # симетрична різниця (C⊕D) - елементи, що належать C АБО D,
    # але не обом (унікальні для кожної множини)
    symm_diff_set = C ^ D
    
    return union_set, symm_diff_set

# Завдання 3.4.2. на словники
# Напишіть функцію, яка інвертує словник (значення стають ключами, ключі – 
# значеннями). Як ви вирішите проблему, якщо вихідні значення не є унікальними?
# ключами є слова з тексту, а значеннями – їхня частота появи. 

# функція інвертує словник (значення стають ключами, ключі – 
# значеннями). Як ви вирішити проблему, якщо вихідні значення не є унікальними
def invert_dictionary(input_dict: dict) -> dict:
    inverted_dict = {}
    
    # ітерація по парах ключ-значення
    for key, value in input_dict.items():
        # ключ (старе значення) повинен бути хешованим (незмінюваним)
        # перевіряємо чи нове значення (старий ключ) вже існує
        if value in inverted_dict:
            # якщо існує, додаємо старий ключ до списку
            inverted_dict[value].append(key)
        else:
            # якщо не існує, створюємо новий запис зі списком для зберігання ключів
            inverted_dict[value] = [key]
            
    return inverted_dict


if __name__ == '__main__':
    print()
    print("***** ТЕСТУВАННЯ ЗАВДАНЬ ПУНКТУ 3 КР1 ВАРІАНТ 2 ******")
    
    # Тест 3.2.2.1
    print("\n* Завдання 3.2.2.1 на одновимірний список *")
    print("* Дано список слів. Знайти та вивести найдовше слово та кількість його входжень у список *")
    print()
    words = ["стул", "диван", "полиця", "полиця", "полиця"]
    longest, count = find_longest_word(words)
    print(f"список: {words}")
    print(f"найдовше слово: '{longest}', кількість входжень: {count}")
    
    # Тест 3.2.2.2
    print("\n* Завдання 3.2.2.2 на вкладений список *")
    print("* Дано квадратну матрицю N×N. Поміняти місцями k-й рядок з m-м рядком (де k та m — задані індекси *)") 
    M = [[1, 2, 3], 
         [4, 5, 6], 
         [7, 8, 9]]
    k, m = 0, 2 #обмін 0-го та 2-го рядків
    print("\nМатриця до: ", M)
    # виклик функції
    M_swap = swap_rows_of_matrix(M, k, m)
    print("Матриця після: ", M_swap, f" (Рядки {k} <-> {m})")
    
    # Тест 3.2.2.3
    print("\n* Завдання 3.2.2.3 на список та кортеж *")
    print("* Приклад для пояснення чому кортежі використовуються для повернення кількох значень із функції * ")
    print("\nКортежі використовують, оскільки вони упорядковані та незмінювані,")
    print("і це гарантує, що повернені дані не змінюються ззовні")
    print("Python автоматично пакує значення у кортеж (напр., return a, b).")
    res = explain_tuple_return(R=5)
    print(f"Приклад: Функція повертає: {res}")
    print(f"Тип поверненого об'єкта: {type(res)}")
    
    # Тест 3.3.3.
    print("\n* Завдання 3.3.3. на множини *")
    print("* Дано дві множини C та D. Знайдіть їхнє об'єднання та симетричну різницю (C⊕D) *")
    C = {1, 2, 3, 4}
    D = {3, 4, 5, 6}
    union_res, diff_res = sets_union_and_diff(C, D)
    print(f"\nмножина C: {C}")
    print(f"множина D: {D}")
    print(f"об'єднання (C ∪ D): {union_res}")
    print(f"симетрична різниця (C ⊕ D): {diff_res}")
    
    # Тест 3.4.2.
    print("\n* Завдання 3.4.2. на словники *")
    print("* Напишіть функцію, яка інвертує словник *")
    test_dict = {'a': 11, 'b': 17, 'c': 11, 'd': 13}
    # Значення '10' є неунікальним (від 'a' та 'c')
    inverted = invert_dictionary(test_dict)
    print(f"\nбув словник: {test_dict}")
    print(f"інвертований словник: {inverted}")
    print("значення '11' має ключі ['a', 'c'] у списку\n")

   